# Семантика типов данных языка RusMatushka

## Поддерживаемые типы данных

### 1. Числовые типы
| Тип                      | Ключевое слово   | Описание									  | Примеры					|
|--------------------------|----------------  |--------------------------------------------	  |-----------------------	|
| Число с плавающей точкой | `number`         | 128-битное число с фиксированной точностью    | `3.14`, `-2.5`, `0.0`   |

### 2. Строковый тип
| Тип    | Ключевое слово | Описание						  | Примеры									  |
|--------|----------------|-----------------------------------|-------------------------------------------|
| Строка | `string`       | Строка символов в кодировке UTF-8 | `"Hello"`, `""`, `"line\n"`			  |

### 3. Логический тип
| Тип        | Ключевое слово | Описание			| Литералы    |
|------------|----------------|---------------------|-------------|
| Логический | `boolean`     | Логическое значение | `true`, `false` |

### 4. Пустой тип (void)
| Тип    | Ключевое слово | Описание							 | Использование	   |	
|--------|----------------|-----------------------------------|---------------------|
| Пустой | (отсутствует)  | Отсутствие возвращаемого значения | Функции без `: тип` |

### 5. Массивы
| Тип     | Описание                                                                 | Примеры                                      |
|---------|--------------------------------------------------------------------------|----------------------------------------------|
| Массив  | `arr of T`, где `T` — базовый тип (`number`, `string`, `boolean`)        | `var a : arr of number = [1, 2, 3];`        |
| Элемент | Тип элемента совпадает с типом элемента массива                         | `a[0]`, `a[i]` — чтение и запись             |

- Литерал массива: тип каждого выражения должен совпадать с типом элемента массива. Длина определяется количеством элементов.
- Индекс в `a[index]` должен иметь тип `number`. Выход за границы массива — ошибка времени выполнения (или по правилам реализации).

### 6. Структуры
| Тип   | Описание                                                                 | Примеры                                           |
|-------|--------------------------------------------------------------------------|---------------------------------------------------|
| Структура | Тип с именованными полями заданных типов                             | `struct { x : number, y : number }`              |
| Поле  | Тип поля задаётся в объявлении структуры                                | `p.x`, `p->y` — чтение и запись                   |

- Литерал структуры: должны быть инициализированы все поля типа; тип каждого выражения должен совпадать с типом соответствующего поля.
- Доступ к полю: выражение слева от `.` или `->` должно иметь тип структуры, содержащей это поле.

## Объявление и инициализация переменных

### Правила инициализации:
1. Переменные должны быть инициализированы перед использованием
2. Тип выражения должен соответствовать объявленному типу переменной
3. Приведение типов запрещено

## Типизация выражений

### Арифметические операции:
| Операция    | Типы операндов		 | Тип результата		  |
|-------------|------------------    |------------------------|
| `+ - * / %` | `number`, `number`   | `number`				  |
| `+`         | `string`, `string`   | `string` (конкатенация)|

### Операции сравнения:
| Операция			| Типы операндов       | Тип результата |
|-------------------|--------------------  |----------------|
| `== != < > <= >=` | `number`, `number`   | `boolean`	    |
| `== != < > <= >=` | `string`, `string`   | `boolean`	    |
| `== !=`           | `boolean`, `boolean` | `boolean`	    |

### Логические операции:
| Операция | Типы операндов      | Тип результата |
|----------|---------------------|----------------|
| `@ \|\| !` | `boolean`, `boolean` | `boolean`	  |

## Типы функций

### Функции с возвращаемым значением:
```
	function sum(a: number, b: number) : number
	begin
		return a + b;
	end
```

### Функции без возвращаемого значения (void):
```
	function greet(name: string)
	begin
		write("Hello, ", name);
	end
```

### Правила:
1. Функция без `: тип` имеет пустой тип возврата
2. Пустая функция может использовать `return` без выражения
3. Функция с типом возврата должна возвращать значение через `return выражение`
4. Все ветки выполнения должны возвращать значение совместимого типа

## Семантические правила типов

### 1. Совместимость присваивания
```
	var y : number = 3.14;      
	string s = "hello";
	y = 5.0;                  // Ok
	y = s;                   // Ошибка number != string
```

### 2. Условные выражения
```
	if (x > 0)              // x должен быть числовым типом
	if (ready)              // ready должен быть boolean
```
### 3. Циклы
```
	while (true)            // OK: boolean
	while (x < 10)          // OK: сравнение возвращает boolean
	while (1)               // Ошибка: число вместо boolean
```
### 4. Встроенные функции
```
	abs(-5)                 // Возвращает number
	min(1.00, 2.00, 3.00)   // Все аргументы должны быть одного числового типа
```
### Обработка ошибок типов
	Несоответствие типов при присваивании - ошибка 

	Использование неинициализированной переменной - ошибка

	Неявное приведение типов - ошибка

	Отсутствие возврата в функции с типом - ошибка

	Возврат несовместимого типа - ошибка

	Несовпадение типа индекса с number при доступе к элементу массива - ошибка

	Несовпадение типа элемента в литерале массива с типом массива - ошибка

	Обращение к несуществующему полю структуры - ошибка

	Не все поля инициализированы в литерале структуры или тип значения поля не совпадает - ошибка

### Символы
	поддерживаются в формате utf-8


# Спецификация семантики языка
## Область видимости
- Ограничена блоками кода (`begin...end`)
- Объявленная переменная в области видимости должна использоваться только в этой области видимости и в дочерней области
- после завершения функции, локальная переменная, объявленная в этой области видимости не доступна извне
- Функции не захватывают переменные внешней области видимости

## Уникальность имён
- В пределах одной области видимости не должны повторяться имена переменных, в разных - можно
- Переменные и функции используют разные пространства имён
- Можно объявить переменную с именем, совпадающим с именем функции в другой области видимости
- Нельзя скрыть имена встроенных функций и типов данных
- При наличии переменной с тем же именем во внешней области видимости, внутренняя переменная скрывает внешнюю

## Параметры функций
- параметры передаются по значению.
- в объявлении функции при указании параметров указывается их тип.
- Тип и порядок параметров в объявлении функции должны совпадать с вызовом функции
- Нельзя скрыть параметр локальной переменной с тем же именем (ошибка компиляции)
- Параметру можно присвоить новое значение внутри функции
- Фактические параметры вычисляются слева направо перед вызовом функции
- Функция с возвращаемым типом должна заканчиваться оператором return выражение
- Функция без возвращаемого типа может заканчиваться без return или с return;

## Рекурсия
- Внутри исполняемого блока функции может быть вызвана эта же функция
- Поддерживается взаимная рекурсия (две функции могут вызывать друг друга)
- Для взаимной рекурсии функции должны быть объявлены в одной области видимости
- Нет ограничений на глубину рекурсии (ограничено только стеком выполнения)

## Ветвления
- В условиях ветвлений (if) должно использоваться выражение типа boolean
- При истинном условии выполняется блок после then
- При ложном условии выполняется блок после else (если присутствует)
- Нет аналога switch..case
- Все блоки в ветвлениях должны быть явными (begin...end)

## Циклы
### Цикл while
- Выполняется, пока выражение в условии возвращает true
- Условие должно иметь тип boolean
- Выражение условия вычисляется перед каждой итерацией
- Если условие ложно с самого начала, цикл не выполняется ни разу

### Цикл for
- Идентификатор после for создаёт новую переменную в области видимости цикла
- Выражения from и to вычисляются один раз перед началом цикла
- Переменная цикла изменяется от начального значения до конечного включительно
- На каждой итерации проверяется, не превысила ли переменная цикла конечное значение
- Тип переменной цикла и границ должен быть number

#### Операторы управления циклами
break - немедленно завершает выполнение текущего цикла
continue - переходит к следующей итерации текущего цикла
break и continue допустимы только внутри циклов

## Присваивания
- В левой части присваивания допускаются: идентификатор переменной, доступ к элементу массива `a[index]`, доступ к полю структуры `obj.field` или `obj->field`
- Нельзя присваивать литералам, вызовам функций или произвольным выражениям
- Присваивание проверяет совместимость типов во время компиляции: тип правой части должен совпадать с типом элемента массива или типом поля структуры
- Тип переменной нельзя изменить после объявления

## Инициализация переменных
- при объявлении переменной без явной инициализации, она инициализируется по умолчанию (string - "", number - "0", boolean - "false").
- Массивы и структуры при объявлении могут быть инициализированы литералом; при отсутствии инициализации — по правилам реализации (например, требование явной инициализации).
- Все переменные должны быть явно инициализированы перед использованием
- Параметры функций считаются инициализированными
- Переменная цикла for инициализируется значением выражения from
